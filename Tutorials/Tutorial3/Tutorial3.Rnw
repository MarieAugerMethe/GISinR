\documentclass{article}
\usepackage{hyperref}
\usepackage[top=2in, bottom=1.5in, left=1in, right=1in]{geometry}
\usepackage{exercise}

% For formating of R code
%\newcommand{\SpatialPolygons}{\texttt{SpatialPolygons}}
%\newcommand{\Polygons}{\texttt{Polygons}}
%\newcommand{\Polygon}{\texttt{Polygon}}
%\newcommand{\SpatialLines}{\texttt{SpatialLines}}

% For tilde
\usepackage{xspace}
\newcommand{\mytilde}{\lower.80ex\hbox{\char`\~}\xspace}



\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Hooks
% Hook for tilde
<<setup, include=FALSE>>=
library(knitr)
hook_source = knit_hooks$get('source')
knit_hooks$set(source = function(x, options) {
  txt = hook_source(x, options)
  # extend the default source hook
  gsub('~', '\\\\mytilde', txt)
})
@
<<setupOp, include=FALSE>>=
opts_chunk$set(fig.width=4, fig.height=4, fig.align="center", tidy=TRUE,
               tidy.opts=list(blank=FALSE, width.cutoff=52),
               size="large")
@

\author{Marie Auger-M\'eth\'e}
\title{GIS in R: Tutorial 3}
\date{}
\maketitle

\large
\section{\texttt{SpatialPolygons}}
\subsection{Components of \texttt{SpatialPolygons}}
In the last tutorial with introduced \texttt{SpatialLines} and some of the basic concepts being \texttt{SpatialPolygons}. In particulat, the nesting of classes for polygons are the same as for the lines. The only difference is that \texttt{Polygon} object, the base object to create \texttt{SpatialPolygons}, have more slots:


<<compSlots>>=
library(sp)
getSlots("Polygon")
getSlots("Line")
@

Just like the \texttt{bbox} slot of \texttt{Spatial*} objects, the slots \texttt{labpt}, the label point (centroid of the polygon), \texttt{area}, the area of the polygon in the metric of the coordinates, and \texttt{ringDir}, the ring direction, are generated automatically. However, the slot \texttt{hole} which would be set as NA need more attention. Note that R does not check whether the lines cross or polygons have errors. Unlike other GIS software, the polygon functions do not check with the features are simple. The \texttt{Polygons} class aslo have more slots than the \texttt{Lines}.

<<compSlot2>>=
getSlots("Polygons")
getSlots("Lines")
@

Here again the slots \texttt{labpt} and \texttt{area} are generally generated automatically. The \texttt{labpt} is the centroid of the largest \texttt{Polygon} constituing a \texttt{Polygons} object and the \texttt{area} of a \texttt{Polygons} object is the sum of all \texttt{Polygon} objects it contains. Note that the \texttt{labpt} is useful when we want to label polygons and uses the charater string saved in the \texttt{ID} to label. The slot \texttt{plotOrder} is also usually generated automatically basde on the size of the \texttt{Polygon} object and is the order in which the \texttt{Polygon} should be plotted. Finally, the \texttt{SpatialPolygons} have only one extra slot compared to the \texttt{SpatialLines}.

<<compSlots3>>=
getSlots("SpatialPolygons")
getSlots("SpatialLines")
@

The \texttt{plotOrder} slot only defined how the order in which the \texttt{Polygons} should be plotted and is generally generated automatically based on the size of the \texttt{Polygons}, largest first. Just like a \texttt{SpatialLines} object needs a list of \texttt{Lines} object, the \texttt{SpatialPolygons} take a list of \texttt{Polygons}. Note the just like \texttt{SpatialLines} objects, \texttt{SpatialPolygons} are the level at which the coordinate reference system (CRS) is set. Similarly, just like \texttt{Line} objects, the \texttt{Polygon} object are the level at which the the coordinates are set.

\subsection{Creating \texttt{SpatialPolygons}}

It's rare that you need to create \texttt{SpatialPolygons} from their raw coordinates. You often use polygon data that has already been created, (e.g. maps of the world) or tranform spatial data from another source (e.g., raster to polygon).

We will load a map of Canada that is in a shapefile object saved in the tutorial folder. To impoart a shapefile you need the package \texttt{rgdal}. Note that you'll need all four WestCoast files. 

<<ImportShp>>=
library(rgdal)
wC <- readOGR(dsn=".", layer="WestCoast")
# This already a SpatialPolygonsDataFrame
class(wC)
# It already has a CRS
proj4string(wC)
@

DISCUSS FURTHER THE IMPORT OF DATA

\subsubsection{\texttt{SpatialPolygons} from \texttt{SpatialPoints}}

However, one case that I find is often useful is when I need to create a \texttt{SpatialPolygons} object to represent the study area on a bigger map. Something, I'll show you how to do here using the Ocean Tracking Network (OTN) Kintama project data (more informationon the project website: \url{http://members.oceantrack.org/data/discovery/KNTM.htm}). The file kintama.csv is a modified version from the file animal.csv found on the OTN public data website (\url{http://members.oceantrack.org/data/discovery/bypublic.htm#K}). First we will create a \texttt{SpatialPointsDataFrame}.

<<spPoints>>=
# Import data
kntm <- read.csv("kintama.csv")
kntm <- unique(kntm)
head(kntm)
# Create a SpatialPointsDataFrame object
coordinates(kntm) <- ~longitude +latitude
proj4string(kntm) <- CRS("+proj=longlat +datum=WGS84")
# Plot the point on the map of Canada
plot(wC)
plot(kntm, col="blue", pch=19, add=TRUE, cex=0.5)
@

While we can see where the points are, a nicer way to just show the study area would be to create a \texttt{SpatialPolygons} that represent the study area. For this we can use the bounding box (\texttt{bbox}) from our \texttt{SpatialPoints}. First we need to get the coordinates of the bounding box

<<bbox>>=
# Get the bounding box of the Spatialpoints object
bbox(kntm)
# We know that the SpatialPolygons should have a points for all combination of these points. You can use expand.grid to do this
studyA <- expand.grid(long=bbox(kntm)["longitude",],lat=bbox(kntm)["latitude",])
studyA
# However, that's not enough. The coordinates should be in order in which you would trace the polygon clockwise. So c(minx, miny), c(minx,maxy), c(maxx, maxy), c(maxx, miny)
studyA <- studyA[c(1,3,4,2),]
# The last trick, is that a polygon needs to be a closed line so the first and last locations need to be the same.
# Here we repeat the first location at the end and bind it with rbind
studyA <- rbind(studyA,studyA[1,])
# We can make these SpatialPoints
coordinates(studyA) <- ~long+lat
proj4string(studyA) <- proj4string(kntm)
# Let's plot these
plot(studyA, col="red", pch=19, cex=0.5)
plot(kntm, col="blue", pch=19, add=TRUE, cex=0.5)
plot(wC, add=TRUE)
box()
@

Now we can create a \texttt{SpatialPolygons} from the \texttt{SpatialPoints}. We are using the same hierarchy as for the \texttt{SpatialLines}

<<spPoly, fig.width=9, fig.height=4.2>>=
studyASP <- SpatialPolygons(list(Polygons(list(Polygon(studyA)), ID = "Study site")), proj4string=CRS(proj4string(studyA)))
# Let's plot it
layout(matrix(1:2,nrow=1))
# First panel: zoomed out view
plot(wC)
# I'm using rgb to make stranparant colour
plot(studyASP, border="red", col=rgb(1,0,0,0.5), add=TRUE)
# Second panel: zoomed in view
plot(studyASP, border="red")
plot(wC, add=TRUE)
plot(kntm, col="blue", pch=19, add=TRUE, cex=0.5)
@

\subsection{Holes in polygons}

\texttt{R} is not a true GIS and does not represent polygons by their topology. Instead the package \texttt{sp} deals with polyons with holes by marking polygons as hole by using the \texttt{hole} slot and the ring direction (clockwise for nonholes, represented with 1, and anti-clokwise for holes, represeted with -1.). The specifications of \texttt{SpatialPolygons} in \texttt{sp} are not consistent with those of the Open Geospatial Consortium. The \texttt{rgeos} package does however, adn thus require each hole to be associated with the exterior ring.  To be able to create compatible \texttt{Polygons}, you can use the \texttt{createSPComment} function to associated each \texttt{Polygons} object from the \texttt{SpatialPolyons}. Exterior rings are coded zero, while interior rings are coded with the 1-based index of the exterior ring to which they belong.

Here we will investigate a \texttt{SpatialPolygonsDataFrame} I've created that has a hole in it.

<<hr>>=
# Read the simulated polygons
HR <- readOGR(dsn=".", layer="hrSP")
# Plot the SpatialPolygonsDataFram
plot(HR, col=rgb(0,0,1))
# We want to look at each Polygon object. To do this we need to get the Polygons out of the SpatialPolygonsDataFrame.
HR <- slot(HR,"polygons")[[1]]
# We then need the list of Polygon objects out of the Polygons
hr <- slot(HR, "Polygons")
# Now we can see that there are 2 Polygon objects
length(hr)
# The first Polygon is not a hole
slot(hr[[1]], "hole")
# So its ring direction is clockwise: 1
slot(hr[[1]], "ringDir")
# We can also look at it's area
slot(hr[[1]], "area")
# Now we cab look at the secon Polygon. Is it a hole
slot(hr[[2]], "hole")
# So its ring should be anticlokwise: -1
slot(hr[[2]], "ringDir")
# What's its area, much smaller 
slot(hr[[2]], "area")
@


MAYEB USE RIVER FROM MAPDATA PACKAGES SINCE THOSE ARE SALMONS.

\subsubsection{\texttt{SpatialPolygons} from \texttt{SpatialLines}}

HOME RANGE EXAMPLE?


MAYBE PUT AN EXAMPLE WITH AN MAINLAND AND ISLAND.

\section{Visualisation}

Traditional graphics, done with the function \texttt{plot} are made incrementaly, where graphic elements added with a set of different functions. The \texttt{sp} package provide a tradiational \texttt{plot} function.

Trellis graphics, e.g. those assocaited with the package \texttt{lattice} (and ggplot2?) alllow to plot high-dimensional data by providing conditiong plots, sets of plots with shared axis. The \texttt{sp} package also provide a \texttt{spplot} function that use the trellis system from the lattice package.

\subsection{Traditional plots}

One advantage of plotting a \texttt{Spatial*} object is that the units in the x and y coordinates are of equal length if the data is projected and using a good aspect ratio for geographical coordinate reference system (CRS). Note that this can be adjusted using the \texttt{asp} argument (see \texttt{?asp}). This is in contrast to plotting non spatial objects.

<<plotBase, fig.width=9, fig.height=6>>=
layout(matrix(1:2,nrow=1))
#
plot(kntm, pch=19, cex=0.5)
plot(wC, add=TRUE)
title(main="Spatial object")
# Plot normal object, use coordinates
plot(coordinates(kntm), pch=19,cex=0.5)
plot(wC, add=TRUE)
title(main="Matrix with coordinates")
@

You can notice a few difference. The plot with the matrix of coordinates looks distorded, but not the plot of the \texttt{Spatial*} object. Another difference is that the \texttt{Spatial*} object doesn't plot the axis automatically, but the plot of the matrix does. To add axis on the a plot of \texttt{Spatial*} object, you can use the argument \texttt{axes}. Some of the \texttt{par} arguments to make changes to the appearance can also be used directly in the \texttt{plot} function, e.g., make the y-axis labels horizontal rather than vertical using \texttt{las}. You can use the function \texttt{axis} to add axis with specific format. Note that you can add axis title using and main graphic title using the function \texttt{title}.

<<axes, fig.width=9, fig.height=8>>=
layout(matrix(1:4, nrow=2))
# Plot a spatial object with axes
plot(kntm, axes=TRUE)
# Make the y-axis label horizontal
plot(kntm, axes=TRUE, las=1)
# Make plot and add x-axis with axis
plot(kntm)
# 1 specify that it's the x-axis
axis(1, at=c(-125,-120))
# add box
box()
# Make a plot and add x-axis with specific label
plot(kntm)
# x-axis with specified label and color for ticks
axis(1, at=c(-125,-120), labels=c("125 W", "120 W"), col.ticks="green")
# y-axis color for both line and ticks
axis(2, at=c(46,50), labels=c("46 N", "50 N"), col="red")
# add title and x-axis title
title("Using axis()", xlab="Longitude")
@

Margin size and other ploting parameters can be adjusted for all graphics using the function \texttt{par}. For example, the argument \texttt{mar} can be used to set the margin size in units of height of a line of text. The order of the argument \texttt{mar} is bottom, left, top, and right margins.


<<margin, fig.width=9, fig.height=4>>=
layout(matrix(1:2, nrow=1))
# plot with original margin
plot(kntm, axes=TRUE)
par(mar=c(3,1,1,1))
plot(kntm, axes=TRUE)
@

You can add a North arrow and a scale bar

<<NscaleMyLocation>>=
plot(kntm, axes=TRUE)
box()
SpatialPolygonsRescale(layout.north.arrow(),offset=c(-118, 49.8), plot.grid=FALSE)
SpatialPolygonsRescale(layout.scale.bar(), offset = c(-127,45.2), fill = c("transparent", "black"), plot.grid = FALSE)
# add the value for scale
text(x=-126.9,y=45.6, "0 ")
text(x=-125.9,y=45.6, expression(1*degree))
# You can use the locator to choose the location, (uncomment the code below)

#SpatialPolygonsRescale(layout.north.arrow(),offset=locator(1), plot.grid=FALSE)

#SpatialPolygonsRescale(layout.scale.bar(), offset = locator(1), fill = c("transparent", "black"), plot.grid = FALSE)

#text(locator(1), "0")

#text(locator(1), expression(1*degree))

@

To add grid lines, you can use the function \texttt{gridlines}.
This is not so great see p. 83
<<gridLines>>=
plot(kntm,axes=TRUE, las=1)
# Create a SptialLines object for the Spatial object you interested in
kntmGrid <- gridlines(kntm, easts=seq(-140,-110, by=1), norths=seq(44,60,by=1))
kntmGrida <- gridat(kntm, easts=seq(-140,-110, by=1), norths=seq(44,60,by=1))
class(kntmGrid)
plot(kntmGrida, add=TRUE, lty=2, col="grey")
box()
@


Multiple \texttt{Spatial*} objects can be added to a plot using the argument \texttt{add=TRUE}. This can be thought as the equivalent of adding layers on top of the orginal layer. By default the plot will be to the extent of the first layer plotted. An alternative method is to use the function \texttt{points} to add {SpatialPoints} objects or \texttt{lines} to add \texttt{SpatialLines}.

<<plotBase2>>=
layout(matrix(1:2,nrow=1))
plot(wC)
plot(kntm, add=TRUE, col="blue")
# An alternative, the default points are different
plot(wC)
points(kntm, col="blue")
@

The geographical area that is plotted in a plot of a \texttt{Spatial} object  is by default the area of data extended by a minimum of 4\% margin of each side. You can contorl how much you are zoomed in by using the argument \texttt{xlim} and \texttt{ylim}.

<<zoom, fig.width=9, fig.height=8>>=
layout(matrix(1:4,nrow=2))
# Original
plot(kntm, axes=TRUE, las=1)
plot(wC, add=TRUE)
# Zoom in
plot(kntm, axes=TRUE, xlim=c(-126,-119), ylim=c(45,47), las=1)
plot(wC, add=TRUE)
# Zoom out
plot(kntm, axes=TRUE, xlim=c(-160,-120), ylim=c(40,60), las=1)
plot(wC, add=TRUE)
@

As you might noticed this is not perfect and that's because the geographical margin are partly fixed by  plot size. You can change the plot size using the \texttt{par} function. 
Not sure how great that part is. Maybe put the table on p. 68.

<<plotsize>>=
# To set own zoom
pin <- c(1,1) # Size in inches
xx <- c(-160,-120)
yy <- c(40,55)
ratio <- diff(xx)/diff(yy)
par(pin = c(ratio * pin[2], pin[2]), xaxs = "i", yaxs = "i")
plot(kntm, axes=TRUE, xlim=xx, ylim=yy, las=1)
plot(wC, add=TRUE)
@

Often what is of interest is to plot the attributes, for example the salmon species of the Kintama projetc.

<<att, fig.width=9, fig.height=4>>=
layout(matrix(1:2,nrow=1))
# Look at salmon species
salmonSp <- unique(kntm$scientificname, drop=TRUE)
# These are class factor which is great, as the numbers will be 
class(salmonSp)
# how many species
length(salmonSp)
# Choose colours
salCol <- c("blue", "red", "yellow", "green", "purple")
# change color
plot(kntm, axes=TRUE, las=1, pch =19, col =salCol[kntm$scientificname],
     cex=0.5)
# we don't see mykiss becasue it's under other dots
plot(wC, add=TRUE)
# Add lengend
legend("topright", legend=salmonSp, col=salCol, pch=19, bty="n", cex=0.55)

# Change size and color
salSiz <- 1:5/5
plot(kntm, axes=TRUE, las=1, pch =19, cex =salSiz[kntm$scientificname],
     col =salCol[kntm$scientificname])
# we don't see mykiss becasue it's under other dots
plot(wC, add=TRUE)
# Add lengend, change text font
legend("topright", legend=salmonSp, col=salCol, pch=19, bty="n", cex=0.55, 
       pt.cex=salSiz, text.font = 3)

@

But to be able to make nice plots with attributes it's better to use the function \texttt{spplot} and the trellis plots.

\end{document}
\documentclass{article}
\usepackage{hyperref}
\usepackage[top=2in, bottom=1.5in, left=1in, right=1in]{geometry}
\usepackage{exercise}

% For formating of R code
%\newcommand{\SpatialPolygons}{\texttt{SpatialPolygons}}
%\newcommand{\Polygons}{\texttt{Polygons}}
%\newcommand{\Polygon}{\texttt{Polygon}}
%\newcommand{\SpatialLines}{\texttt{SpatialLines}}

% For tilde
\usepackage{xspace}
\newcommand{\mytilde}{\lower.80ex\hbox{\char`\~}\xspace}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Hooks
% Hook for tilde
<<setup, include=FALSE>>=
library(knitr)
hook_source = knit_hooks$get('source')
knit_hooks$set(source = function(x, options) {
  txt = hook_source(x, options)
  # extend the default source hook
  gsub('~', '\\\\mytilde', txt)
})
@
<<setupOp, include=FALSE>>=
opts_chunk$set(fig.width=4, fig.height=4, fig.align="center", tidy=TRUE,
               tidy.opts=list(blank=FALSE, width.cutoff=52),
               size="large")
@

\author{Marie Auger-M\'eth\'e}
\title{GIS in R: Tutorial 4}
\date{}
\maketitle

\large
\section{Extracting informatiom}

Read rivers from Bristich Columbia, data that was taken from \url{http://www.empr.gov.bc.ca/MINING/GEOSCIENCE/MAPPLACE/GEODATA/Pages/default.aspx} and the data from the OTN Kintama project (bla bla bla). Note that I have transform the kintama data for it to be in the same projection as the rivers which is BC Albers (see \url{http://spatialreference.org/ref/epsg/nad83-bc-albers/}).

<<bcdata>>=
library(rgdal)
# OTN slamon point data
kntm <- readOGR(dsn=".", layer="kntmAlbers")
# River is BC
rivers <- readOGR(dsn=".", layer="bcRivAlbers")
# Same projection
identical(proj4string(kntm), proj4string(rivers))
# What's in those files
names(kntm)
names(rivers)
spplot(kntm, zcol="scntfcn", col.regions=brewer.pal(6, "Reds")[-1],
       sp.layout=list("sp.lines", rivers, col="blue"))
@


% Mayb put that part with polygons

rgeos 
Geometry Engine - Open Source (GEOS) and Java Topology Suite (JTS) only handle planar geometries, so the data should be projected. 

I think that's in contrast to things like gDistance package and spdep which has great circle distance?

<<rgeos>>=
library(rgeos)
# Minimum distance?
getScale()
@

JTS and GEOS follow the OpenGIS(R) simple features specificaion, in whic polygons may have only one exterior boundary ring and an unlimited number of interior boundaries (i.e. unlimitedt number of holes). Becasue \texttt{sp} \texttt{Polygons} are multi-polygon objects (can have multiple \texttt{Polygon} objects that each have a distinct exterior boundary, e.g. province mainland and all of the province islands can be lumpped under one \texttt{Polygons} object and thus associated with one ID) there is no direct match between GEOS simple feature polygons and \texttt{SpatialPolygons} objects. This means that for \texttt{Polygons} object to be exported to GEOS, they need to have an appropriate \texttt{comment} attribute. This only affects polygons, not points and lines. Polygons can be checked using the createSPComment function from rgeos or the maptools checkPolygonHoles, see p.132- 133 Bivand

Get area, many ways, rgeos function need planar. The area slot will give you an area in any uint... but taht moght not make sense.

<<>>=
Area <- gArea(olinda_utm, byid = TRUE)
totArea <- gArea(olinda_utm)
olinda_utm$area <- sapply(slot(olinda_utm, "polygons"), slot, "area")
all.equal(unname(Area), olinda_utm$area)
@

<<addnewcol>>=
olinda_utm$dens <- olinda_utm$V014/(olinda_utm$area/1e+06)
@

Check if polygons overlap?
<<gOverlaps>>=
pols_overlap <- gOverlaps(olinda_utm, byid = TRUE)
any(pols_overlap)
# Maybe discuss the problems associated with scale
oScale <- getScale()
setScale(10000)
pols_overlap <- gOverlaps(olinda_utm, byid = TRUE)
any(pols_overlap)
bounds <- gUnaryUnion(olinda_utm)
setScale(oScale)
sapply(slot(slot(bounds, "polygons")[[1]], "Polygons"), slot, "area")
@



Create only polygon from multiple with gUnaryUnion
<<gUnaryUnion>>=
bounds <- gUnaryUnion(olinda_utm)
summary(bounds)
summary(olinda_utm)
plot(bounds)
# Maybe lump county that have a high density
boundsHigDens <- gUnaryUnion(olinda_utm[olinda_utm$dens>1000,])
summary(boundsHigDens)
plot(boundsHigDens)
@

length of geometry, what does it means for points? and polygons?

<<gLength>>=

@

Whether object touches, makes a matrix for each oject can be byid or comparing two objects.
<<>>=
t0 <- gTouches(stream_utm, byid = TRUE)
# Maybe add merge?
# also SpatialLinesLengths with great circle distance
@

<<gIntersect>>=
gInstersect vs [object2,]
gIntersect byID give lines per polygons
@

Include gbuffer!
<<gBuffer>>=

@


Maybe use blue shark data and seal data.

I've included the Northwest Atalantic Fisheries Organization (NAFO) divisions shapefile, which I found on the NAFO website at \ulr{http://www.nafo.int/data/frames/data.html}. 

<<NAFOZone>>=
library(rgdal)
NAFO <- readOGR(".", "Divisions")
# Note that they use NAD83 as a geographic CRS
proj4string(NAFO)
plot(NAFO)
@


Clipping, simply by subseting.



<<>>=
SPobj1
SPobj2
# NEED TO HAVE EXACTLY THE SAME PROJ4
clipSPobj1 <- SPobj1[SPobj2,]
@

Maybe do it by clipping the rivers available in the study area of Kintama example.
Talk about over, how it gives the attributes from the for the object2, instead of obj1.

<<over>>=
sel <- over(stations, lnd)
head(sel,15)
names(lnd)
names(stations)
summary(sel)

@

Use aggregate length with spatialpoints to get at the number of points in a polygon

<<Aggregate>>=

@


Create random points

<<>>=
library(spatstat)
dran <- runifpoint(100, win = as.vector(t(bbox(ds))))
#create 100 random points
plot(ds)
plot(dran, add = T)
@


\end{document}
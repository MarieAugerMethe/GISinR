\documentclass{article}
\usepackage{hyperref}
\usepackage[top=2in, bottom=1.5in, left=1in, right=1in]{geometry}
\usepackage{exercise}

% For formating of R code
%\newcommand{\SpatialPolygons}{\texttt{SpatialPolygons}}
%\newcommand{\Polygons}{\texttt{Polygons}}
%\newcommand{\Polygon}{\texttt{Polygon}}
%\newcommand{\SpatialLines}{\texttt{SpatialLines}}

% For tilde
\usepackage{xspace}
\newcommand{\mytilde}{\lower.80ex\hbox{\char`\~}\xspace}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Hooks
% Hook for tilde
<<setup, include=FALSE>>=
library(knitr)
hook_source = knit_hooks$get('source')
knit_hooks$set(source = function(x, options) {
  txt = hook_source(x, options)
  # extend the default source hook
  gsub('~', '\\\\mytilde', txt)
})
@
<<setupOp, include=FALSE>>=
opts_chunk$set(fig.width=6, fig.height=5, fig.align="center", tidy=TRUE,
               tidy.opts=list(blank=FALSE, width.cutoff=52),
               size="large")
@

\author{Marie Auger-M\'eth\'e}
\title{GIS in R: Tutorial 4}
\date{}
\maketitle

\large
\section{Extracting informatiom}

We are going to read river and boundary data based on the data found on the Natural Earth website and the data from the OTN Kintama project (bla bla bla). This is cropped to close to the ara we might need.

<<bcdata>>=
library(rgdal)
# OTN slamon point data
kntm <- readOGR(dsn=".", layer="kntm")
# Main rivers
mainRiv <- readOGR(dsn=".", layer="mainRivers")
# Smaller rivers
smallRiv <- readOGR(dsn=".", layer="smallRivers")
# Administrative boundaries and coast lines
bounds <- readOGR(dsn=".", layer="borders")
# Same projection?
identical(proj4string(kntm), proj4string(mainRiv))
identical(proj4string(kntm), proj4string(smallRiv))
identical(proj4string(kntm), proj4string(bounds))
# Ok we are good, they are all the same

# What's in those files
names(kntm)
names(mainRiv)
names(smallRiv)
names(bounds)

# Let's take a quick look
library(RColorBrewer) # For color palette (brewer.pal)
spplot(kntm, zcol="scntfcn", col.regions=brewer.pal(6, "Reds")[-1],
       sp.layout=list(list("sp.polygons", bounds),
                      list("sp.lines", mainRiv, col="blue"),
                      list("sp.lines", smallRiv, col="lightblue")))
@

One of the first thing we might like to do here is to lump the rivers into one layer, because in our case we don't particularly care whether they are big or small rivers and the division is only made because the data came into two different layers. Here, some of the rivers intersect. We can use the \texttt{rgeos} package tool \texttt{gInstersection} to investigate that.

<<binding2layers>>=
library(rgeos)
# Find area where mainRIv intersects with smallRiv
rivInt <- gIntersection(mainRiv, smallRiv)
plot(bounds)
plot(mainRiv, add=TRUE, col="blue")
plot(smallRiv, add=TRUE, col="lightblue")
plot(rivInt, add=TRUE, col="green", pch=19, cex=0.5)
@

Here we would like to create one object with no interseting lines. We can use the \texttt{rgeos} \texttt{gUnion} function, which will join intersecting geometries.

<<gUnion>>=
rivAll <- gUnion(mainRiv, smallRiv)
# We now have all the rivers in one layer
plot(bounds)
plot(rivAll, add=TRUE, col="blue")
# What's the object created?
class(rivAll)
# So we lost the data associated with the mainRiv and smallRiv

# How many lines objects is there? (remember only lines object can have an ID and thus attributes)
length(rivAll)
# In contrast smallRiv and mainRiv had many more Lines objects
length(smallRiv)
length(mainRiv)
@

So gUnion creates one object with one Lines.


Now let's say we would like to focuss only on the salmon from United States. For this we can make a new polygon that lumps all american polygons using another union tool \texttt{gUnaryUnion} from rgeos. We can then use this new polygon to crop the layers to be only of the extent of this new polygon using \texttt{gIntersection}.


<<gIntersection>>=
# So we want all polygons from the bounds that are of the admin== Unite States of America
usa <- bounds[bounds$admin == "United States of America",]
plot(usa)
class(usa)
summary(usa)
# now we want to create one big polygon that we will use to clip the rest of the data
usaB <- gUnaryUnion(usa)
# We can see now that we only have the surrounding border
plot(usaB, add=TRUE, border="purple")
# But what is the new object?
class(usaB)
length(usaB)
# Just one SpatialPolygons, with no data
@

Now we can use this usaB polygon to clip the other layers using \texttt{gIntersection}.

<<gIntersection2>>=
# Get the rivers in the usa
usaRiv <- gIntersection(rivAll, usaB)
# Get the slamons in the usa
usaKntm <- gIntersection(kntm, usaB)
# let's plot these new layers
plot(bounds)
plot(usaB, add=TRUE, border="purple", lwd=2)
plot(usaRiv, col="blue", add=TRUE)
plot(usaKntm, col="red", add=TRUE, pch=19, cex=0.5)
# Great but what's in new layers
class(usaRiv)
length(usaRiv)
class(usaKntm)
length(usaKntm)
@

So this is great but the returned object don't have data anymore. What if we wanted to keep the data? One option is to use the indexing. This is particularly useful for SpatialPointsDataFrame.

<<subsetting>>=
# For Spatial* objects you can subset using anoth Spatial object.
# For example you can take only the data points that are in the usaB
usaKntm2 <- kntm[usaB,]
# Just like before this is going to have only the american points
plot(bounds)
plot(usaB, add=TRUE, border="purple", lwd=2)
plot(usaKntm2, add=TRUE, col="red", pch=19, cex=0.5)
# unlike the usaKntm object made above this will have data
class(usaKntm)
class(usaKntm2)
# The same columns as in the kntm we are subsetting from
identical(names(usaKntm2), names(kntm))

# While gIntersection works for polygons and lines it will not clip the lines and polygon to the border, what it does is take all lines that goes inside the usaB but keeps that parts that are outside. Here I'm using the mainRiv to give you a good examples.
usaRiv2 <- mainRiv[usaB,]
plot(mainRiv, add=TRUE, col="lightblue")
plot(usaRiv2, add=TRUE, col="blue")
# But it keeps the data
class(usaRiv2)
identical(names(usaRiv2), names(mainRiv))
@

A case that might often happen is that you want to summarise the data based from one layer based whether they fall in another layer. For example, here one might be interested in understand how many species of salmon have been captured in each of the regions of our study area. To do this you can use the function \texttt{aggrate}.

<<aggregate>>=
# Get the number of species in each regions
nSp <- function(x){length(unique(x))}
regionsSp <- aggregate(kntm[c("scntfcn")], by=bounds, FUN=nSp)
summary(regionsSp)
# Note that we get NA instead of 0
# We can replace thse values using is.na function
regionsSp$scntfcn[is.na(regionsSp$scntfcn)] <- 0
names(regionsSp)
# Setting colors for salmon species
salCol <- c("red", "pink", "green", "purple", "blue")
salSiz <- 1:5/5
spplot(regionsSp, zcol="scntfcn", col.regions=brewer.pal(7, "Reds"), cuts=6,
       sp.layout=list("sp.points", kntm, pch=19, 
                      col=salCol[kntm$scntfcn],cex=salSiz[kntm$scntfcn]))
@


Another example is that we might want to some the number of detections taken at ecah receivers. Which we can also do with aggregate. But here we want to aggregate by locations.

<<aggregate2>>=
# So we can get the unique data location
recLoc <- data.frame(unique(coordinates(kntm)))
coordinates(recLoc) <- ~ coords.x1 + coords.x2
proj4string(recLoc) <- CRS(proj4string(kntm))
length(recLoc)
length(kntm)
plot(kntm)
plot(recLoc, add=TRUE, pch=19, col="red", cex=0.5)
# Now we can use this recLoc to get at how many detectionwe got per receiver
nDe <- function(x){length(x)}
decPerRec <- aggregate(kntm[c("scntfcn")], by=recLoc, FUN=nDe)
summary(decPerRec)
names(decPerRec)
bubble(decPerRec, zcol="scntfcn", col="red",
       sp.layout=list(list("sp.polygons", bounds),
                      list("sp.lines", rivAll, col="blue")),
       main="Detections per receiver")
@


In general Geometry Engine - Open Source (GEOS) and Java Topology Suite (JTS) only handle planar geometries, and it's better to use projected CRS. This is especially true when one wants to look at area and distances. In fact, if you try to get the area using \texttt{gArea} on data with geographical CRS, you'll get a warning,

<<gAreaWarning>>=
gArea(bounds)
@

So let's project our data. Let's use the Universal Tranverse Mercator zone 10 which covers most of our kntm data. This is not perfect since some points are in zone 11, but it should do the trick for now.

<<utmzone10>>=
boundsUTM <- spTransform(bounds, CRS("+proj=utm +zone=10 +datum=WGS84"))
decUTM <- spTransform(decPerRec, CRS("+proj=utm +zone=10 +datum=WGS84"))
riversUTM <- spTransform(rivAll, CRS("+proj=utm +zone=10 +datum=WGS84"))
# Lets' look at it
plot(boundsUTM)
plot(riversUTM, add=TRUE, col="blue")
plot(decUTM, pch=19, cex=0.5, col="red", add=TRUE)
@

Now we should be able to get the area with \texttt{gArea}.

<<gArea>>=
# This will give us the overall area of our SpatialPolygonsDataFrame object
gArea(boundsUTM)
# If we want the area of each polygons object we can use
gArea(boundsUTM, byid=TRUE)
# These are in the units of the projection, so in our case m^2. SO if you want it in km^2 divide by 1 000 000
# We can add these in a new column of the boundsUTM
boundsUTM$size <- gArea(boundsUTM, byid=TRUE)/1000000
# The only provincs/state we have complete is Washington, the others are clipped at the edge, but we can use Washington to check wehther the area estimate is correct
boundsUTM$size[boundsUTM$name == "Washington"]
# According to wikiedia it's 184,827 km2
# So we area a bit off, not too sure why
@


One thing that is often useful is to be able to put a buffer around a feature of interest. For example here we would like to estimate how much river water there close to each salmon points. For this we can use \texttt{gBuffer}.

<<gBuffer>>=
#First let's put a buffer around the rivers of 10 km
riv10k <- gBuffer(riversUTM, width=10000)
# Similarly, let's put a buffer of 25 km arroudn the receivers, but here we wuld like to keep each points indepdent and keep the data and so we use byid=TRUE
dec25k <- gBuffer(decUTM, width=25000, byid=TRUE)
# We now have a SpatialPolygons and SpatialPolygonsDataFrame for dec25k
class(riv10k)
summary(dec25k)
plot(boundsUTM)
plot(riversUTM, col="blue", add=TRUE)
plot(riv10k, col=rgb(0,0,0.7,0.5), border=NA, add=TRUE)
plot(decUTM, col="red", add=TRUE, pch=19, cex=0.5)
plot(dec25k, col=rgb(1,0,0,0.5), border=NA, add=TRUE)
@

Now we would like to see how much water edge, represented by the 10k buffer, is in the vacinity (25k buffer) of each receiver. This is a completely artificial example and the buffer are really big just so we can visualise them easily.

<<gOverlaps>>=
rivInRec <- gIntersection(riv10k, dec25k, byid=TRUE)
# Now we will have new polygons for each intersection, but that means that if some dec25 did not intersect with the river buffer we will have fewer number of polygons
length(rivInRec)
length(dec25k)
#This is the case
plot(dec25k, col="red", border=NA)
plot(rivInRec, add=TRUE)
plot(riv10k, col=rgb(0,0,0.7,0.5), border=NA, add=TRUE)
plot(boundsUTM, add=TRUE)
box()
# So now we want to associate the the rivInRec data to the good rec row
# The name of the rivInRec data is associated to that or dec25k
head(row.names(rivInRec))
head(row.names(dec25k))
# Now we want to use strsplit to divided the name of rivRec and get the name of rec25
divName <- strsplit(row.names(rivInRec), " ")
# It gives a list wth each element having 2 element
head(divName,3)
length(divName[[1]])
# We only want the second element and will get this with sapply
divName <- sapply(divName, "[", 2)
head(divName)
# Now we can create a new column in dec25k that will contain the amount of river edge we have in the buffer of the receiver and put 0.
dec25k$H2O <- 0
# We can calculate the arae using garea of the intersetc and add for the value to the associated row
dec25k$H2O[match(divName,row.names(dec25k))] <- gArea(rivInRec, byid=TRUE)
# Looks qualitatively ok
spplot(dec25k, zcol="H2O",
       sp.layout=list(list("sp.polygons",rivInRec,col="blue"),
                      list("sp.polygons", riv10k, fill=rgb(0,0,1,0.5), col=NA),
                      list("sp.polygons", boundsUTM)))
@


% 
% 
% Note that I have transform the kintama data for it to be in the same projection as the rivers which is BC Albers (see \url{http://spatialreference.org/ref/epsg/nad83-bc-albers/}).
% 
% % Mayb put that part with polygons
% 
% 
% I think that's in contrast to things like gDistance package and spdep which has great circle distance?
% 
% <<rgeos>>=
% library(rgeos)
% # Minimum distance?
% getScale()
% @
% 
% JTS and GEOS follow the OpenGIS(R) simple features specificaion, in whic polygons may have only one exterior boundary ring and an unlimited number of interior boundaries (i.e. unlimitedt number of holes). Becasue \texttt{sp} \texttt{Polygons} are multi-polygon objects (can have multiple \texttt{Polygon} objects that each have a distinct exterior boundary, e.g. province mainland and all of the province islands can be lumpped under one \texttt{Polygons} object and thus associated with one ID) there is no direct match between GEOS simple feature polygons and \texttt{SpatialPolygons} objects. This means that for \texttt{Polygons} object to be exported to GEOS, they need to have an appropriate \texttt{comment} attribute. This only affects polygons, not points and lines. Polygons can be checked using the createSPComment function from rgeos or the maptools checkPolygonHoles, see p.132- 133 Bivand
% 
% Check if polygons overlap?
% <<gOverlaps>>=
% pols_overlap <- gOverlaps(olinda_utm, byid = TRUE)
% any(pols_overlap)
% # Maybe discuss the problems associated with scale
% oScale <- getScale()
% setScale(10000)
% pols_overlap <- gOverlaps(olinda_utm, byid = TRUE)
% any(pols_overlap)
% bounds <- gUnaryUnion(olinda_utm)
% setScale(oScale)
% sapply(slot(slot(bounds, "polygons")[[1]], "Polygons"), slot, "area")
% @
% 
% 
% 
% length of geometry, what does it means for points? and polygons?
% 
% <<gLength>>=
% 
% @
% 
% Whether object touches, makes a matrix for each oject can be byid or comparing two objects.
% <<>>=
% t0 <- gTouches(stream_utm, byid = TRUE)
% # Maybe add merge?
% # also SpatialLinesLengths with great circle distance
% @
% 
% 
% 
% Maybe use blue shark data and seal data.
% 
% I've included the Northwest Atalantic Fisheries Organization (NAFO) divisions shapefile, which I found on the NAFO website at \ulr{http://www.nafo.int/data/frames/data.html}. 
% 
% <<NAFOZone>>=
% library(rgdal)
% NAFO <- readOGR(".", "Divisions")
% # Note that they use NAD83 as a geographic CRS
% proj4string(NAFO)
% plot(NAFO)
% @
% 
% 
% Maybe do it by clipping the rivers available in the study area of Kintama example.
% Talk about over, how it gives the attributes from the for the object2, instead of obj1.
% 
% <<over>>=
% sel <- over(stations, lnd)
% head(sel,15)
% names(lnd)
% names(stations)
% summary(sel)
% 
% @
% 
% Use aggregate length with spatialpoints to get at the number of points in a polygon
% 
% <<Aggregate>>=
% 
% @
% 
% 
% Create random points
% 
% <<>>=
% library(spatstat)
% dran <- runifpoint(100, win = as.vector(t(bbox(ds))))
% #create 100 random points
% plot(ds)
% plot(dran, add = T)
% @
% 
% Nearest neibhour

\end{document}
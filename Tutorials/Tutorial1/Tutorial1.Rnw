\documentclass{article}
\usepackage{hyperref}
\usepackage[top=2in, bottom=1.5in, left=1in, right=1in]{geometry}
\usepackage{exercise}

% Paragraph indentation and line skip
\setlength{\parindent}{0cm}
\setlength{\parskip}{3mm plus2mm minus1mm}

% For tilde
\usepackage{xspace}
\newcommand{\mytilde}{\lower.80ex\hbox{\char`\~}\xspace}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Hook for tilde
<<setup, include=FALSE>>=
library(knitr)
hook_source = knit_hooks$get('source')
knit_hooks$set(source = function(x, options) {
  txt = hook_source(x, options)
  # extend the default source hook
  gsub('~', '\\\\mytilde', txt)
})
@
<<setupOp, include=FALSE>>=
opts_chunk$set(fig.width=4, fig.height=4, fig.align="center", tidy=TRUE,
               tidy.opts=list(blank=FALSE, width.cutoff=52))
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\author{Marie Auger-M\'eth\'e}
\title{GIS in R: Tutorial 1}
\date{}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Good R practices}

If you want to be able to reproduce your analyses, it is important to keep track of your files, write down all coding steps, and preferably do version control. Keeping track of your steps is both important to make your research reproducible and easily shareable, and just because it is nice not to have to start from scratch every time you want to do an analysis.

\subsection{Keep all our files in one place with R Studio projects}

This is particularly important for spatial analyses because spatial data files can be challenging to handle and keeping all files in the same folder facilitate the process. Keep originals somewhere else so only changes stuff.

\subsection{Make reproducible examples with R scripts}

Share complete analysis by sending an R script. Put comments!

\textbf{\textit{For those that are taking the class for credit, I want you to send me by e-mail for each tutorial a \texttt{R} script that has all of the code from the tutorial, including the code found in the document.}}

\subsection{Keep track of your changes with version control}

\section{\texttt{Spatial} class}

Vector data (i.e., Points, Lines, and Polygons) are handle in \texttt{R} using the foundation class \texttt{Spatial} associated with the package \texttt{sp}. To get a feel for how \texttt{Spatial} objects differ from other types of \texttt{R} objects, we will import a .csv table with the locations of bioprobes (this is a simplified version of the data available on the \href{http://members.oceantrack.org/data/discovery/SGS.htm}{Ocean Tracking Network (OTN) website}).

<<>>=
# Read the .csv file with OTN Sable Island bioprobe data
bioPr <- read.csv("sableSealBioP.csv")
@

To get a sense for this object we will investigate the class, and some of the generic functions.

<<>>=
# What's the class?
class(bioPr)
# Can we summarise the information within it?
summary(bioPr)
@

One of the generic function is the \texttt{plot} functions.

<<dataframeplot>>=
plot(bioPr)
@

Since we know that the data includes the locations of bioprobes, it would be much better to be able to plot it spatially. To do this we will trasform this \texttt{data.frame} into a \texttt{Spatial} object. In particular, since our data is point data, we will transform the data.frame into a \texttt{SpatialPointsDataFrame}. The simplest way to do so is by assigning values to \texttt{coords} slot, which is the component that contains the coordinate values.

<<>>=
# Load package
library(sp)
# Create new data.frame with the exact same value as bioPr
bioPrSP <- bioPr 
# Transform this new object into a SpatialPointsDataFrame using the columns that contain the latitude and longitude values
colnames(bioPrSP)
coordinates(bioPrSP) <- ~longitude+latitude
@

Now let's compare the results from the same generic functions.
<<>>=
class(bioPrSP)
summary(bioPrSP)
@

We see now the bounding box (\texttt{bbox}) with the min and max values of the coordinates. We know that the data is not projected and that the \texttt{proj4string} slot has a missing value, more on this below. We also see that we have 727 points, which correspond to the 727 rows of the original \texttt{data.frame}. Finally we see a summary of the attributes of the points, which is the same summary as the one for the orginal data frame, when you exclude the columns with the coordinates.

But more interestingly, let's look at the \texttt{plot} function.
<<>>=
plot(bioPrSP)
# With an added box around the figure
box()
@

Here instead of plotting the data values from all the columns the plot shows the location of the row in space.

\section{Projection}

While this is great, this plot is not particularly informative. In part, because we don't have any reference points that tells us where the locations are. In Canada? In New Zealand?

To be able to put reference points we need to give to make sure the \texttt{proj4string} slot of the \texttt{Spatial} object is set to the correct projection. When we ran \texttt{summary(bioPrSP)} above, we could see both the Is projected is NA and the proj4string is NA, indicating that the data doesn't have a projection. This is not surprising since we have not specified the projection. We can confirm this with the \texttt{proj4string}.

<<>>=
proj4string(bioPrSP)
is.projected(bioPrSP)
@

Coordinate reference systems (CRS), which are used to represent the earth on a plane, are essential part of GIS and had been the focus of cartography.

I'm assuming that the latitude and longitude data from OTN is the conventional GPS data using WGS84 datum. To set it, you can use again the 

<<>>=
proj4string(bioPrSP) <- CRS("+proj=longlat +datum=WGS84")
# Now bioPrSP has as datum
proj4string(bioPrSP)
# But it's still not projected
is.projected(bioPrSP)
@

That's because lat lon is not a projection... bla bla bla, and we can set another value to proj4strig, need to projtranform... bla bla bla

<<introGDAL>>=
library(rgdal)
@

<<addCanada>>=
library(maps)
# Get a coarse map of Canada using the packages maps
canada <- map("world", "canada", resolution=0, fill=TRUE)
plot(bioPrSP)
map(canada, add=TRUE)
box()
@

<<worldProj, fig.width=9, fig.height=4>>=
library(maptools) # Need maptools for pruneMap and map2SpatialPolygons
# This is not a an Spatial object from the package sp like bioPr
# Instead it's a object class map
# Remove the limit 
worldMap <- map("world", resolution=0, fill=TRUE, plot=FALSE, xlim=c(-179,179), ylim=c(-89,89))
worldMap <- pruneMap(worldMap, xlim=c(-179,179))
# But you can transform it into a spatial object using
IDs <- sapply(strsplit(worldMap$names, ":"), function(x) x[1])
worldSP <- map2SpatialPolygons(worldMap, IDs=IDs, proj4string = CRS("+proj=longlat +ellps=WGS84"))

# Now let's look at transformations
layout(matrix(1:2, nrow=1))
plot(worldSP)
box()
# Projecting to Mollweide projection
worldSPmoll <- spTransform(worldSP, CRS("+proj=moll"))
plot(worldSPmoll)
box()
@


Error when you have locations that are outside coordinates system, this can happen for example if there is a typo or for data that come from highly error-prone system (e.g. light curve location system). bla bla
{
\raggedright
<<>>=
# Create a duplicate data.frame
bioPr2 <- bioPr
# We will put a non-sensical coordinate in the data frame
bioPr2$longitude[1] <- -300 # -300 degree longitude makese no sense
head(bioPr2)
# Now let's try to create the spatial object again, using the same steps
bioPrSP2 <- bioPr2
coordinates(bioPrSP2) <- ~longitude+latitude
proj4string(bioPrSP2) <- CRS("+proj=longlat +datum=WGS84")
@
}
We get an error because the longitude value -300 doesn't exist in the coordinate system we chose. As a result the object remains without a coordinate system.

<<>>=
proj4string(bioPrSP2)
@

If you remove the row with the non-conformat data, you'll be able to assign the coordinate system.

<<>>=
# Get the index for the non-conformant coordinates
ncLonLat <- which(coordinates(bioPrSP2) == -300, arr.ind=TRUE)
# We know it should be in row 1, col 1, since we've put it there
ncLonLat
# Remove that row
bioPrSP2 <- bioPrSP2[-ncLonLat[,1],]
# Now assign the coordinate system
proj4string(bioPrSP2) <- CRS("+proj=longlat +datum=WGS84")
@

\section{Attributes: subsetting}
What if we wanted to create a object that only include a subset of the location. In this example we would like to only have the Atlantic cod (\textit{Gadus morhua}) locations.

<<>>=
# Only take the points that have "Gadus morhua" in the column scientificname
codPrSP <- bioPrSP[bioPrSP$scientificname == "Gadus morhua",]
# We now have 0 Halichoerus grypus, but we can see that the subset will keep the coordinate system, but will update the bounding box
summary(codPrSP)
# For example compare
bbox(bioPrSP)
bbox(codPrSP)
@

The object class we have been using so far, \texttt{SpatialPointsDataFrame}, is actually a more complex level class for point data. I've presented first, because it's the class that I find the more useful because most of my data is poits with some kind of attributes. However, there may be cases where the data you have is only coordinates, with no further attributes associated with them. In this case you would use a \texttt{SpatialPoints} class. For example, let's say we only have the locations of the bioprobes, with no information on the species, sex, age, etc..

<<>>=
# We are making a bit of an artifical example here by first getting the coordinates of the bioPrSP
bioPrCoord <- coordinates(bioPrSP)
# Now let assume that this new object is the only information we have
summary(bioPrCoord)
# We can create a SpatialPoints object as follow
bioPrCoordSP <- SpatialPoints(bioPrCoord, proj4string = CRS("+proj=longlat +ellps=WGS84"))
# This now a SpatialPoints object, without any attribute
summary(bioPrCoordSP)
# That can be plotted just like before
plot(bioPrCoordSP)
box()
@

It can happen that you may have the coordinated information coming from a different file than the file in which you have information. In which case you can put the two together using the \texttt{match.ID} option of \texttt{SpatialPointsDataFrame}. The idea here is similar to matching rows of database based on their unique key. So here the unique key is the name of the row. So for example let's say we want to match the coordinates of the bioprobes found in the matrix \texttt{bioPrCoord} back to the data.frame \texttt{bioPr}.

<<>>=
# First indentify whether the objects have row name
str(row.names(bioPrCoord))
str(row.names(bioPr))
# While bioPr has number values from 1-727, bioPrCoord doesn't.
# We know that bioPrCoord should be in the same order as bioPr, becasue we've created bioPrCoord from bioPr. So I think we could use directly
bioPrSP3 <- SpatialPointsDataFrame(bioPrCoord, bioPr, proj4string = CRS("+proj=longlat +ellps=WGS84"), match.ID = TRUE)
 # Note that match.ID=TRUE is the default value, so you don't need to specify it.
# We can see that the rows are adequately associated with teh coordinates. Just comapre the longitude and latitude columns to the coordinates
bioPrSP3[1:5,]
# Now just for fun let's mix up the row on bioPrCoord, in this case if we want the row.names to be assign.
row.names(bioPrCoord) <- 1:727
# Then we can sample at random and the row name will be the same
bioPrCoordM <- bioPrCoord[sample(1:727,727),] 
# We see now that compare to the original the row are mixed randomly, be the original row name remains associated with it's original row
head(bioPrCoordM)
head(bioPrCoord)
# Now we can create a spatial object that will use the row names, even if mixed randomly, to match the data.frame of attributes to the coordinates
bioPrSP4 <- SpatialPointsDataFrame(bioPrCoordM, bioPr, proj4string = CRS("+proj=longlat +ellps=WGS84"), match.ID = TRUE)
# Now the order is mixed up but the coordinates still correspond to the good row of the attributes.
bioPrSP4[1:5,]
@

Note that if the row names don't match up, you won't be able to create a \texttt{SpatialPointsDataFrame}

<<>>=
# Creating a duplicate of the coordinate matix
bioPrCoordN <- bioPrCoord
# Giving new names, which don't match with one of the 727 orginal names, to the first 5 rows
row.names(bioPrCoordN)[1:5] <- 1001:1005
bioPrSP5 <- SpatialPointsDataFrame(bioPrCoordN, bioPr, proj4string = CRS("+proj=longlat +ellps=WGS84"), match.ID = TRUE)
@

Note that they are other ways in which you can construct a \texttt{SpatialPointsDataFrame}, including by linking a \texttt{data.frame} to a \texttt{SpatialPoints} object.

<<SPpointsDataFrame>>=
# Here we don't need to specify the coordinate system and projection, because the SpatialPoints object already has this information.
bioPrSP6 <- SpatialPointsDataFrame(bioPrCoordSP, bioPr)
# It should be the same has linking the matrix of coordinate
identical(bioPrSP3, bioPrSP6)
@

A final way which is similar to the one presented in my orginial example, is using the \texttt{coordinates} function.

<<>>=
# Make a duplicate of the data.frame
bioPrSP7 <- bioPr
coordinates(bioPrSP7) <- bioPrCoord
class(bioPrSP7)
# To add the projection, you can just use proj4string
proj4string(bioPrSP7) <- CRS("+proj=longlat +ellps=WGS84")
@

Ok, so I've presented multiple ways to associated attributes to locations and create a \texttt{SpatialPointsDataFrame}. But why should we bother? Well, one of the great thing about attributes is that they can be used to create symbols in plots.

<<spplot>>=
spplot(bioPrSP,zcol="scientificname")
@

But more on this on the next class!

\section{Exercise}

\begin{Exercise}

Create a spatial object with the data found in nbCod.csv, which is a slightly altered version from the Animal file available on the Shippagan, NB: Code tagging project from OTN, see \href{http://members.oceantrack.org/data/discovery/SPI.htm}{project website}.

\end{Exercise}

\end{document}

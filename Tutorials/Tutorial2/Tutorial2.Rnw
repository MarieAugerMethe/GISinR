\documentclass{article}
\usepackage{hyperref}
\usepackage[top=2in, bottom=1.5in, left=1in, right=1in]{geometry}

% For tilde
\usepackage{xspace}
\newcommand{\mytilde}{\lower.80ex\hbox{\char`\~}\xspace}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Hooks
% Hook for tilde
<<setup, include=FALSE>>=
library(knitr)
hook_source = knit_hooks$get('source')
knit_hooks$set(source = function(x, options) {
  txt = hook_source(x, options)
  # extend the default source hook
  gsub('~', '\\\\mytilde', txt)
})
@
<<setupOp, include=FALSE>>=
opts_chunk$set(fig.width=4, fig.height=4, fig.align="center", tidy=TRUE,
               tidy.opts=list(blank=FALSE, width.cutoff=52),
               size="large")
@

\author{Marie Auger-M\'eth\'e}
\title{GIS in R: Tutorial 2}
\date{}
\maketitle

\large
\section{\texttt{Spatial} class}

Maybe show how lattice works based by showing a series of plots with different years of tagging

LOOK AT gmap
Look at ggplot2 projections
ARE OBJECT FROM map S4 class object

%%%%%%%%%%%

Today will investigate two new classes of \texttt{Spatial} objects: \texttt{SpatialLines} and \texttt{SpatialPolygons}. Both of these classes are more complex than the \texttt{SpatialPoints} class we investigated during the last tutorial. First we will explore the slots associated with these objects. Remember that slots are the important component of the object. To get the slots of an class, you can use the function \texttt{getSlots}.

<<SpatialClass>>=
# The are all object associated with the sp package
library(sp)
# Get slots of SpatialPoints
getSlots("SpatialPoints")
# Get slots of SpatialLines
getSlots("SpatialLines")
# Get slots of SpatialPolygons
getSlots("SpatialPolygons")
@

We can note here that the SpatialPoints need the slots: \texttt{coords} with the coordinates of each points, \texttt{bbox} with the bounding box (extent) of the points, and \texttt{proj4sting} which has the coordinate reference system (CRS). While both the \texttt{SpatialLines} and \texttt{SpatialPolygons} use the \texttt{bbox} and \texttt{proj4string} just like the \texttt{SpatialPoints}, they do not use \texttt{coords} slots and instead use \texttt{lines} and \texttt{polygons}. These two slots are in fact list of objects of class \texttt{Line} and \texttt{Polygon}.  

<<linespolygons>>=
# Note that both these have slots that are lists.

# Get the slots of Lines
getSlots("Lines")
# Get the slots of Polygons
getSlots("Polygons")
@

The lists will take a list of object of class Line or Polygon, and each of the Line and Polygon in the list will need to be associated with an ID in the ID slot. The very basis of the \texttt{SpatialLines} and \texttt{SpatialPolygons} are the class \texttt{Line} and \texttt{Polygon}, which as we can see below are the class that have a slot for coordinates.

<<LinePolygon>>=
# Look at the slots of the fundamental class for SpatialLines
getSlots("Line")
# Look at the slots of the fundamental class for SpatialPolygon
getSlots("Polygon")
# Note that both have the coords slot
@


\subsection{\texttt{SpatialLines}}

Here we are going to create a \texttt{SpatialLines} object based on the location of a grey seal. The data used here is the data from REFERENCE HERE. Just to use the simplest example possible, we will make a \texttt{SpatialLines} object with only one seal.

<<seal1>>=
# Read files with movement data
sealMov <- read.csv("Seal3_169_2_01_1.csv")
# Let's look at the first column to get a sense of what's in the file
head(sealMov)
# How many seals do we have and what's their ID
unique(sealMov$SealID)
# Get only the points for seal 66486
seal1 <- subset(sealMov, SealID == 66486 ,drop=TRUE)
@

Now we want to order the locations of the seal by date, so when we connect the points with lines they are ordered to represent the movement of the animal. To do this we will use the \texttt{DateTime} class, which is an important class in R.

<<OrderingDate>>=
# The class of the date column is factor, which is not great for ordeing dates
class(seal1$Date)
# Make the date time into a POSIXlt class, which is a basic class for date and time in R. This class understand how time should be ordered. You need to specify the format of the data and the time zone (which we are assuming is UTC), see ?POSIXlt
seal1$Date <- as.POSIXlt(seal1$Date, format="%d.%m.%y %H:%M:%S", zone="UTC")
# Now the class is POSIXlt
class(seal1$Date)
# We can now order the seal1 object by date and time
seal1 <- seal1[order(seal1$Date),]
@

Now, we will create a \texttt{SpatialPointsDataFrame} object based on the location of the seal like we did in the last tutorial. 

<<sealSpPoint>>=
# We can create a SpatialPointsDataFrame by assigning the coordinates
coordinates(seal1) <- ~Lon + Lat
# We then assign the geographic CRS, which we are assuming is WGS84
proj4string(seal1) <- CRS("+proj=longlat +datum=WGS84")
# Now we have a SpatialPointsDataFrame object
class(seal1)
@

Now we will create a \texttt{Line} using the \texttt{SpatialPointsDataFrame}.

<<sealLine>>=
# Creat a Line object
seal1L <- Line(seal1)
# Now the class is Line
class(seal1L)
# Can we plot it?
plot(seal1L)
# What's the info
summary(seal1L)
@

You have noticed that the \texttt{Line} object we just created is not useful in itself. All it does is assess that all of the points are associated with one line. In our case all of the locations of this seal is associated with one movement path. The \texttt{Line} object needs to be incorporated in a \texttt{Lines} object. Note that the \texttt{Lines} object is a list of \texttt{Line} with an associated ID. The \texttt{Lines} object is also of little interest by itself, it's only a building block for the \texttt{SpatialLines}.

<<sealLines>>=
# Create a Lines object using a Line
seal1Ls <- Lines(seal1L, ID="seal1")
# You can't plot it
plot(seal1Ls)
# And the info is not that interesting
summary(seal1Ls)
# But let's create a SpatialLines object with this Lines object. Note that to make SpatialLines you need a list of Lines
seal1SpL <- SpatialLines(list(seal1Ls))
# Now we finnally have a Spatial object that can be plotted
plot(seal1SpL)
# Let's add the points
plot(seal1, add=TRUE, pch=19, cex=0.5)
# and a box around the plot
box()
@

Because \texttt{Line} and \texttt{Lines} are not \texttt{Spatial} object and only the \texttt{SpatialLines} object is a \texttt{Spatial} object (with a CRS), you need to specify the CRS. Here we are using the same CRS as the seal locations. Note that the \texttt{SpatialLines}  assume that the animal is moving straight between the points, which may not make sense in all type of CRS, including in nonprojected CRS like the WGS84.

<<spLProj>>=
# Check the current CRS
proj4string(seal1SpL)
# Assign the same CRS as the seal locations which are the base of this SpatialLines object
proj4string(seal1SpL) <- proj4string(seal1)
@

So I've shown you the step-by-step way to go from \texttt{SpatialPointsDataframe} to \texttt{SpatialLines}, but you could combined all of the lines to make one code line.

<<CreateSpLin1L>>=
seal1SpL2 <- SpatialLines(list(Lines(Line(seal1), ID="seal1")), 
                         proj4string=CRS(proj4string(seal1)))
# Because we are just lumping the functions from above, it should give you exactly the same results
identical(seal1SpL, seal1SpL2)
@

An even quicker way to create a \texttt{SpatialLines} from a\texttt{SpatialPointsDataFrame} is to use \texttt{as}.

<<SpPsSpLs>>=
# Creating a SpatialLines from the seal1 SpatialPoints object supper quickly.
seal1SpL3 <- as(seal1, "SpatialLines")
# This will not be exactly the same
identical(seal1SpL, seal1SpL3)
# The only difference here is that sealSpL3 that we just created has the defaut ID "ID", if we create a new SpatialLines but name the ID as "ID" they are going to be identical.
seal1SpL4 <- SpatialLines(list(Lines(Line(seal1), ID="ID")), 
                          proj4string=CRS(proj4string(seal1)))
identical(seal1SpL3, seal1SpL4)
@

So in our first example, we only had one continous movement path, but we might want a \texttt{SpatialLines} object with multiple paths. For example, we might want to have one\texttt{SpatialLines} object with the movement path of the three seals in our sealMov \texttt{data.frame}. In the first case, we would like to have each path to be a different \texttt{Lines} object with a different ID representing the seal ID. So for this we will need to create a \texttt{Lines} object for each seal. 

<<seal2Lines>>=
# Before we create the line objects we would like to order the sealMov based on indibidual and then on time, so we need to make the date column a POSIXlt object. See above for further explanation.
sealMov$Date <- as.POSIXlt(sealMov$Date, format="%d.%m.%y %H:%M:%S", zone="UTC")
# We will select the row by sealID below, so we only need to order it by dates followed by date, use order
sealMovD <- sealMov[order(sealMov$Date),]
# Check the first rows, now date are in order but SealID is mixed
head(sealMovD)

# So we want to create a Lines obeject for the data points associated with each seal, so if we did it for one seal, e.g.: SealID: 66506, we could do it
seal2Ls <- Lines(Line(sealMovD[sealMovD$SealID == 66506, c("Lon","Lat")]), ID = 66506)
# So this is a Lines object
class(seal2Ls)
@

To most efficient way to a \texttt{Lines} for each seal, is through \texttt{lapply}. \texttt{lapply} is a base function in \texttt{R} that applies a function repeatly to object. There are many such function and \texttt{lapply} returns a list. Here is a few very easy examples of \texttt{lapply}.

<<lapplyeg>>=
# To familiarize yourself with lapply, we going to apply it to a simple function
# Create a matrix
oo <- matrix(1:3,nrow=3)
# Just a column with value 1-3
oo
# Here we make an lapply function that adds 1 to the value each each row of oo
lapply(oo, function(x){x+1})
# You could do something more complicated that use two different object. E.g., let's create new matrix
aa <- matrix(1:6, nrow=3)
# Just a matrix with value from 1-6 in two columns
aa
# Now we want to do the mean of each row using lapply. We use oo as the row index, as in if oo is 1 we do mean(aa[1,]).
lapply(oo, function(x){mean(aa[x,])})
@

Now we will use \texttt{lapply} to do a list of \texttt{Lines}. We are going to use the SealID as our index and create one \texttt{Lines} per seal.

<<3sealLines>>=
# Get the id of the 3 seals
sealIndex <- unique(sealMovD$SealID)
sealIndex
# now use the lapply on the code we described above: Lines(Line(sealMovD[sealMovD$SealID == 66506, c("Lon","Lat")]), ID = 66506) 
sealsLs <- lapply(sealIndex, 
       function(x){Lines(Line(sealMovD[sealMovD$SealID == x, c("Lon","Lat")]), ID = x)})
# We should get a list back
class(sealsLs)
# And the elements of this list should be a Lines object
class(sealsLs[[1]])
@


We can now use this list to create a \texttt{SpatialLines}.

<<allsealsSP>>=
# Create a SpatialLines based on the list and assign the CRS
sealsSpL <- SpatialLines(sealsLs, 
                          proj4string=CRS(proj4string(seal1)))
# We can plot it and assign different coulors to the different Lines
plot(sealsSpL, col=c("red","purple","orange"))
# with a box around the plot
box()
@


Note that the \texttt{Lines} object can contain multiple \texttt{Line} but can only be associated with a single ID. The idea is to be able to link multiple \texttt{Line} to the same attributes. To give you an example here,




<<>>=
#> bubble(df2, "z1", key.space = "bottom")
# FOR size
#> spplot(df2, "z1", key.space = "bottom")
@


\end{document}
